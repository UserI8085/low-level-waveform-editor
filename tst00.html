<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCM Wave Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        
        body {
            background: #001100;
            color: #0f0;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1000px;
            width: 100%;
            background: rgba(0, 20, 0, 0.9);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
            margin-top: 10px;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .oscilloscope {
            height: 250px;
            background-color: #000;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            border: 1px solid #00aa00;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            display: block;
        }
        
        .editor {
            display: flex;
            flex-direction: column;
            background: #000c00;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #00aa00;
        }
        
        .editor-tabs {
            display: flex;
            background: #001600;
            border-bottom: 1px solid #00aa00;
        }
        
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            background: #001600;
            color: #0f0;
            border: none;
            font-family: inherit;
            flex: 1;
            text-align: center;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .tab.active {
            background: #00aa00;
            color: #001100;
            font-weight: bold;
        }
        
        .tab:hover {
            background: #003300;
        }
        
        .hex-editor {
            padding: 15px;
            overflow-x: auto;
            flex-grow: 1;
            font-size: 14px;
            background: #000800;
            max-height: 220px;
            display: flex;
            flex-direction: column;
        }
        
        .hex-row {
            display: flex;
            margin-bottom: 5px;
            align-items: center;
        }
        
        .offset {
            color: #00aa00;
            margin-right: 15px;
            width: 50px;
            flex-shrink: 0;
            font-size: 13px;
            font-weight: bold;
        }
        
        .hex-data {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .hex-byte {
            width: 40px;
            text-align: center;
            cursor: pointer;
            padding: 5px;
            background: #002200;
            border-radius: 3px;
            font-size: 13px;
            transition: all 0.2s;
            border: 1px solid #004400;
        }
        
        .hex-byte:hover {
            background-color: #00cc00;
            color: #001100;
            transform: scale(1.05);
        }
        
        .byte-highlight {
            background-color: #00ff00 !important;
            color: #001100 !important;
            font-weight: bold;
            box-shadow: 0 0 8px #00ff00;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            padding: 15px;
            background: #001100;
            border-radius: 6px;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
            border: 1px solid #00aa00;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 4px;
            background: #002200;
            border: 1px solid #004400;
        }
        
        button, select, input {
            background-color: #003300;
            color: #00ff00;
            border: 1px solid #00aa00;
            padding: 8px 15px;
            cursor: pointer;
            font-family: inherit;
            border-radius: 4px;
            transition: all 0.3s;
            font-size: 13px;
        }
        
        button:hover, select:hover {
            background-color: #00aa00;
            color: #001100;
        }
        
        .status-bar {
            padding: 12px 15px;
            background: #001100;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #00ff00;
            border: 1px solid #00aa00;
        }
        
        .sample-pointer {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #ff3366;
            pointer-events: none;
            display: none;
        }
        
        .sample-info {
            position: absolute;
            background: rgba(0, 20, 0, 0.95);
            padding: 8px 15px;
            border: 1px solid #00ff00;
            pointer-events: none;
            display: none;
            font-size: 12px;
            color: #00ff00;
            border-radius: 4px;
            z-index: 10;
        }
        
        .samples-input {
            width: 80px;
            text-align: center;
        }
        
        .smoothness-input {
            width: 70px;
            text-align: center;
        }
        
        .axis-control {
            display: flex;
            gap: 5px;
        }
        
        .axis-btn {
            padding: 5px 10px;
            font-size: 12px;
        }
        
        .axis-btn.active {
            background-color: #00ff00;
            color: #001100;
        }
        
        .wav-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .cycle-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: #002200;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #004400;
        }
        
        .cycle-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .cycle-input {
            width: 60px;
            text-align: center;
        }
        
        .cycle-nav {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .cycle-nav-btn {
            padding: 5px 10px;
            font-size: 12px;
            width: 30px;
        }
        
        @media (max-width: 768px) {
            .main-content {
                gap: 15px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
            
            .hex-byte {
                width: 35px;
                font-size: 12px;
                padding: 4px;
            }
            
            .offset {
                width: 45px;
                margin-right: 10px;
            }
            
            .samples-input {
                width: 70px;
            }
            
            .smoothness-input {
                width: 60px;
            }
            
            .cycle-controls {
                width: 100%;
            }
            
            .cycle-nav {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="oscilloscope">
                <canvas id="waveform"></canvas>
                <div class="sample-pointer" id="samplePointer"></div>
                <div class="sample-info" id="sampleInfo"></div>
            </div>
            
            <div class="editor">
                <div class="editor-tabs">
                    <button class="tab active" data-tab="hex">Hex</button>
                    <button class="tab" data-tab="dec">Decimal</button>
                </div>
                
                <div class="hex-editor" id="hexEditor"></div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="samplesInput">Samples:</label>
                <input type="number" id="samplesInput" class="samples-input" min="16" max="4096" value="64">
            </div>

            <div class="control-group">
                <label for="smoothnessInput">Smooth:</label>
                <input type="number" id="smoothnessInput" class="smoothness-input" min="0" max="100" value="0">
                <span>%</span>
            </div>
            
            <div class="control-group">
                <label>Axis Lock:</label>
                <div class="axis-control">
                    <button id="axisX" class="axis-btn active">X</button>
                    <button id="axisY" class="axis-btn active">Y</button>
                    <button id="axisBoth" class="axis-btn active">Both</button>
                </div>
            </div>
            
            <div class="control-group">
                <button id="save">Save BIN</button>
                <button id="load">Load BIN</button>
            </div>

            <div class="control-group wav-controls">
                <button id="exportWav">Export WAV</button>
                <button id="importWav">Import WAV</button>
            </div>

            <div class="control-group">
                <button id="btnNormalize">Normalize</button>
                <button id="btnReset">Reset</button>
            </div>
            
            <!-- Cycle controls with numeric input -->
            <div class="control-group cycle-controls">
                <div class="cycle-input-group">
                    <label for="cycleCountInput">Total Cycles:</label>
                    <input type="number" id="cycleCountInput" class="cycle-input" min="1" max="100" value="1">
                </div>
                <div class="cycle-input-group">
                    <label for="currentCycleInput">Current Cycle:</label>
                    <div class="cycle-nav">
                        <button id="prevCycle" class="cycle-nav-btn">◀</button>
                        <input type="number" id="currentCycleInput" class="cycle-input" min="1" max="100" value="1">
                        <button id="nextCycle" class="cycle-nav-btn">▶</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div id="status">Samples: 64, Range: 0-65535</div>
            <div id="cursorPos">Pos: 0, Value: 32768</div>
            <div id="selectionInfo">Selected: None</div>
        </div>
    </div>

    <script>
        // Configuration
        const config = {
            waveSize: 64,
            amplitude: 100,
            smoothness: 0,
            selectionStart: -1,
            selectionEnd: -1,
            axisMode: 'both',
            sampleRate: 44100,
            originalWaveData: null,
            cycleCount: 1,
            currentCycle: 1,
            cyclesData: []
        };

        // State
        let waveData = new Uint16Array(config.waveSize).fill(32768);
        let selectedSampleIndex = -1;
        let isDrawing = false;
        let hexByteElements = [];
        let currentView = 'hex';
        let lastSampleIndex = -1;
        let lastValue = 32768;
        
        // DOM Elements
        const canvas = document.getElementById('waveform');
        const ctx = canvas.getContext('2d');
        const hexEditor = document.getElementById('hexEditor');
        const status = document.getElementById('status');
        const cursorPos = document.getElementById('cursorPos');
        const selectionInfo = document.getElementById('selectionInfo');
        const samplePointer = document.getElementById('samplePointer');
        const sampleInfo = document.getElementById('sampleInfo');
        const samplesInput = document.getElementById('samplesInput');
        const smoothnessInput = document.getElementById('smoothnessInput');
        const axisXBtn = document.getElementById('axisX');
        const axisYBtn = document.getElementById('axisY');
        const axisBothBtn = document.getElementById('axisBoth');
        const exportWavBtn = document.getElementById('exportWav');
        const importWavBtn = document.getElementById('importWav');
        const cycleCountInput = document.getElementById('cycleCountInput');
        const currentCycleInput = document.getElementById('currentCycleInput');
        const prevCycleBtn = document.getElementById('prevCycle');
        const nextCycleBtn = document.getElementById('nextCycle');
        
        // Initialize
        function init() {
            resizeCanvas();
            renderHexEditor();
            drawWaveform();
            setupEventListeners();
            updateStatus();
            updateAxisButtons();
            updateCycleControls();
            
            config.originalWaveData = new Uint16Array(waveData);
            config.cyclesData[0] = new Uint16Array(waveData);
        }
        
        function setupEventListeners() {
            document.getElementById('save').addEventListener('click', saveWave);
            document.getElementById('load').addEventListener('click', loadWave);
            
            exportWavBtn.addEventListener('click', exportWav);
            importWavBtn.addEventListener('click', importWav);
            
            samplesInput.addEventListener('change', updateWaveSize);
            
            smoothnessInput.addEventListener('change', handleSmoothnessChange);
            smoothnessInput.addEventListener('input', handleSmoothnessChange);
            
            document.getElementById('btnNormalize').addEventListener('click', normalizeWaveform);
            document.getElementById('btnReset').addEventListener('click', resetWaveform);

            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    currentView = tab.dataset.tab;
                    renderEditor();
                });
            });
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', handleCanvasMove);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);

            canvas.addEventListener('click', handleCanvasClick);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            axisXBtn.addEventListener('click', () => setAxisMode('x'));
            axisYBtn.addEventListener('click', () => setAxisMode('y'));
            axisBothBtn.addEventListener('click', () => setAxisMode('both'));
            
            cycleCountInput.addEventListener('change', updateCycleCount);
            currentCycleInput.addEventListener('change', changeCurrentCycle);
            prevCycleBtn.addEventListener('click', () => navigateCycle(-1));
            nextCycleBtn.addEventListener('click', () => navigateCycle(1));
            
            window.addEventListener('resize', () => {
                resizeCanvas();
                drawWaveform();
            });
        }
        
        // Cycle management functions
        function updateCycleControls() {
            cycleCountInput.value = config.cycleCount;
            cycleCountInput.max = 100;
            
            currentCycleInput.value = config.currentCycle;
            currentCycleInput.max = config.cycleCount;
            
            prevCycleBtn.disabled = config.currentCycle <= 1;
            nextCycleBtn.disabled = config.currentCycle >= config.cycleCount;
        }
        
        function updateCycleCount() {
            let newCycleCount = parseInt(cycleCountInput.value);
            if (isNaN(newCycleCount) || newCycleCount < 1) newCycleCount = 1;
            if (newCycleCount > 100) newCycleCount = 100;
            
            cycleCountInput.value = newCycleCount;
            
            if (newCycleCount !== config.cycleCount) {
                const oldCycleCount = config.cycleCount;
                config.cycleCount = newCycleCount;
                
                if (newCycleCount > oldCycleCount) {
                    for (let i = oldCycleCount; i < newCycleCount; i++) {
                        if (!config.cyclesData[i]) {
                            config.cyclesData[i] = new Uint16Array(config.waveSize);
                            config.cyclesData[i].set(waveData);
                        }
                    }
                } else {
                    config.cyclesData.length = newCycleCount;
                    
                    if (config.currentCycle > newCycleCount) {
                        config.currentCycle = newCycleCount;
                        waveData.set(config.cyclesData[newCycleCount - 1]);
                    }
                }
                
                updateCycleControls();
                drawWaveform();
                renderEditor();
                updateStatus();
            }
        }
        
        function changeCurrentCycle() {
            let newCycle = parseInt(currentCycleInput.value);
            if (isNaN(newCycle) || newCycle < 1) newCycle = 1;
            if (newCycle > config.cycleCount) newCycle = config.cycleCount;
            
            currentCycleInput.value = newCycle;
            
            if (newCycle !== config.currentCycle) {
                config.cyclesData[config.currentCycle - 1] = new Uint16Array(waveData);
                
                config.currentCycle = newCycle;
                if (config.cyclesData[newCycle - 1]) {
                    waveData.set(config.cyclesData[newCycle - 1]);
                } else {
                    config.cyclesData[newCycle - 1] = new Uint16Array(config.waveSize).fill(32768);
                    waveData.set(config.cyclesData[newCycle - 1]);
                }
                
                drawWaveform();
                renderEditor();
                updateStatus();
                updateCycleControls();
            }
        }
        
        function navigateCycle(direction) {
            let newCycle = config.currentCycle + direction;
            if (newCycle >= 1 && newCycle <= config.cycleCount) {
                currentCycleInput.value = newCycle;
                changeCurrentCycle();
            }
        }
        
        function handleSmoothnessChange(e) {
            let newSmoothness = parseInt(e.target.value);
            
            if (isNaN(newSmoothness)) newSmoothness = 0;
            if (newSmoothness < 0) newSmoothness = 0;
            if (newSmoothness > 100) newSmoothness = 100;
            
            smoothnessInput.value = newSmoothness;
            
            if (!config.originalWaveData || config.originalWaveData.length !== waveData.length) {
                config.originalWaveData = new Uint16Array(waveData);
            }
            
            if (newSmoothness > 0) {
                applySmoothing(newSmoothness);
            } else {
                waveData.set(config.originalWaveData);
            }
            
            config.smoothness = newSmoothness;
            drawWaveform();
            renderEditor();
        }
        
        function setAxisMode(mode) {
            config.axisMode = mode;
            updateAxisButtons();
        }
        
        function updateAxisButtons() {
            axisXBtn.classList.toggle('active', config.axisMode === 'x');
            axisYBtn.classList.toggle('active', config.axisMode === 'y');
            axisBothBtn.classList.toggle('active', config.axisMode === 'both');
        }
        
        function updateWaveSize() {
            let newSize = parseInt(samplesInput.value);
            if (isNaN(newSize) || newSize < 16) newSize = 16;
            if (newSize > 4096) newSize = 4096;
            samplesInput.value = newSize;
            
            if (newSize !== config.waveSize) {
                config.waveSize = newSize;
                resizeWaveData();
                config.originalWaveData = new Uint16Array(waveData);
                
                for (let i = 0; i < config.cycleCount; i++) {
                    if (config.cyclesData[i]) {
                        const newCycleData = new Uint16Array(newSize);
                        const copyLength = Math.min(config.cyclesData[i].length, newSize);
                        for (let j = 0; j < copyLength; j++) {
                            newCycleData[j] = config.cyclesData[i][j];
                        }
                        for (let j = copyLength; j < newSize; j++) {
                            newCycleData[j] = 32768;
                        }
                        config.cyclesData[i] = newCycleData;
                    }
                }
                
                if (config.cyclesData[config.currentCycle - 1]) {
                    waveData.set(config.cyclesData[config.currentCycle - 1]);
                }
            }
        }
        
        function resizeCanvas() {
            const width = canvas.parentElement.clientWidth;
            canvas.width = width;
            canvas.height = canvas.parentElement.clientHeight;
            drawWaveform();
        }
        
        function renderEditor() {
            if (currentView === 'hex') {
                renderHexEditor();
            } else if (currentView === 'dec') {
                renderDecimalEditor();
            }
        }
        
        function renderHexEditor() {
            hexEditor.innerHTML = '';
            hexByteElements = [];
            
            const bytesPerRow = 16;
            const rows = Math.ceil(config.waveSize / bytesPerRow);
            
            for (let row = 0; row < rows; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'hex-row';
                
                const offsetDiv = document.createElement('div');
                offsetDiv.className = 'offset';
                offsetDiv.textContent = (row * bytesPerRow).toString(16).padStart(4, '0').toUpperCase();
                rowDiv.appendChild(offsetDiv);
                
                const dataDiv = document.createElement('div');
                dataDiv.className = 'hex-data';
                
                const start = row * bytesPerRow;
                const end = Math.min(start + bytesPerRow, config.waveSize);
                
                for (let i = start; i < end; i++) {
                    const byteDiv = document.createElement('div');
                    byteDiv.className = 'hex-byte';
                    byteDiv.textContent = waveData[i].toString(16).padStart(4, '0').toUpperCase();
                    byteDiv.dataset.index = i;
                    byteDiv.addEventListener('click', () => editByte(i));
                    
                    if (config.selectionStart >= 0 && i >= config.selectionStart && i <= config.selectionEnd) {
                        byteDiv.style.backgroundColor = '#006600';
                    }
                    
                    dataDiv.appendChild(byteDiv);
                    hexByteElements[i] = byteDiv;
                }
                
                rowDiv.appendChild(dataDiv);
                hexEditor.appendChild(rowDiv);
            }
        }
        
        function renderDecimalEditor() {
            hexEditor.innerHTML = '';
            hexByteElements = [];
            
            const bytesPerRow = 16;
            const rows = Math.ceil(config.waveSize / bytesPerRow);
            
            for (let row = 0; row < rows; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'hex-row';
                
                const offsetDiv = document.createElement('div');
                offsetDiv.className = 'offset';
                offsetDiv.textContent = (row * bytesPerRow).toString().padStart(3, '0');
                rowDiv.appendChild(offsetDiv);
                
                const dataDiv = document.createElement('div');
                dataDiv.className = 'hex-data';
                
                const start = row * bytesPerRow;
                const end = Math.min(start + bytesPerRow, config.waveSize);
                
                for (let i = start; i < end; i++) {
                    const byteDiv = document.createElement('div');
                    byteDiv.className = 'hex-byte';
                    byteDiv.textContent = waveData[i].toString().padStart(5, ' ');
                    byteDiv.dataset.index = i;
                    byteDiv.addEventListener('click', () => editByte(i));
                    
                    if (config.selectionStart >= 0 && i >= config.selectionStart && i <= config.selectionEnd) {
                        byteDiv.style.backgroundColor = '#006600';
                    }
                    
                    dataDiv.appendChild(byteDiv);
                    hexByteElements[i] = byteDiv;
                }
                
                rowDiv.appendChild(dataDiv);
                hexEditor.appendChild(rowDiv);
            }
        }

        function normalizeWaveform() {
            let min = 65535;
            let max = 0;
            
            for (let i = 0; i < config.waveSize; i++) {
                if (waveData[i] < min) min = waveData[i];
                if (waveData[i] > max) max = waveData[i];
            }
            
            const range = max - min;
            if (range > 0) {
                for (let i = 0; i < config.waveSize; i++) {
                    waveData[i] = Math.floor(((waveData[i] - min) / range) * 65535);
                }
            }
            
            config.originalWaveData = new Uint16Array(waveData);
            config.cyclesData[config.currentCycle - 1] = new Uint16Array(waveData);
            
            renderEditor();
            drawWaveform();
            status.textContent = "Waveform normalized";
        }
        
        function resetWaveform() {
            if (confirm("Reset waveform to default?")) {
                waveData = new Uint16Array(config.waveSize).fill(32768);
                config.originalWaveData = new Uint16Array(waveData);
                config.cyclesData[config.currentCycle - 1] = new Uint16Array(waveData);
                selectedSampleIndex = -1;
                config.selectionStart = -1;
                config.selectionEnd = -1;
                config.smoothness = 0;
                smoothnessInput.value = 0;
                samplePointer.style.display = 'none';
                renderEditor();
                drawWaveform();
                updateStatus();
                updateSelectionInfo();
                status.textContent = "Waveform reset";
            }
        }

        function applySmoothing(strength) {
            if (strength <= 0) return;
            
            const originalData = config.originalWaveData;
            const smoothed = new Uint16Array(config.waveSize);
            
            for (let i = 0; i < config.waveSize; i++) {
                let sum = 0;
                let count = 0;
                
                for (let j = -2; j <= 2; j++) {
                    const index = i + j;
                    if (index >= 0 && index < config.waveSize) {
                        sum += originalData[index];
                        count++;
                    }
                }
                
                const smoothFactor = strength / 100;
                smoothed[i] = Math.floor(originalData[i] * (1 - smoothFactor) + (sum / count) * smoothFactor);
            }
            
            waveData = smoothed;
            config.cyclesData[config.currentCycle - 1] = new Uint16Array(waveData);
            renderEditor();
        }

        function handleCanvasClick(e) {
            if (e.shiftKey) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const sampleIndex = Math.min(
                    Math.floor((x / canvas.width) * config.waveSize),
                    config.waveSize - 1
                );
                
                if (config.selectionStart === -1) {
                    config.selectionStart = sampleIndex;
                    config.selectionEnd = sampleIndex;
                } else {
                    config.selectionEnd = sampleIndex;
                    if (config.selectionStart > config.selectionEnd) {
                        [config.selectionStart, config.selectionEnd] = [config.selectionEnd, config.selectionStart];
                    }
                }
                
                updateSelectionInfo();
                renderEditor();
                drawWaveform();
            }
        }

        function handleKeyDown(e) {
            if (e.key === 'Escape') {
                config.selectionStart = -1;
                config.selectionEnd = -1;
                updateSelectionInfo();
                renderEditor();
                drawWaveform();
            }
        }

        function handleKeyUp(e) {
            // Handle key up if needed
        }

        function updateSelectionInfo() {
            if (config.selectionStart >= 0) {
                selectionInfo.textContent = `Selected: ${config.selectionStart}-${config.selectionEnd}`;
            } else {
                selectionInfo.textContent = "Selected: None";
            }
        }
        
        function updateHexByte(index) {
            if (hexByteElements[index]) {
                if (currentView === 'hex') {
                    hexByteElements[index].textContent = waveData[index].toString(16).padStart(4, '0').toUpperCase();
                } else {
                    hexByteElements[index].textContent = waveData[index].toString().padStart(5, ' ');
                }
            }
        }
        
        function editByte(index) {
            const currentValue = currentView === 'hex' ? 
                waveData[index].toString(16).padStart(4, '0').toUpperCase() : 
                waveData[index].toString();
                
            const newValue = prompt(`Edit sample value (0-65535):`, currentValue);
            
            if (newValue !== null) {
                let value;
                if (currentView === 'hex') {
                    value = parseInt(newValue, 16);
                } else {
                    value = parseInt(newValue);
                }
                
                if (!isNaN(value) && value >= 0 && value <= 65535) {
                    waveData[index] = value;
                    config.originalWaveData[index] = value;
                    config.cyclesData[config.currentCycle - 1][index] = value;
                    updateHexByte(index);
                    drawWaveform();
                    highlightSample(index);
                    updateStatus();
                } else {
                    alert('Invalid value! Must be between 0 and 65535');
                }
            }
        }
        
        function drawWaveform() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();
            
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const scaleY = canvas.height / 65535;
            
            for (let i = 0; i < config.waveSize; i++) {
                const x = (i / config.waveSize) * canvas.width;
                const y = canvas.height - (waveData[i] * scaleY);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            if (selectedSampleIndex >= 0) {
                const x = (selectedSampleIndex / config.waveSize) * canvas.width;
                const y = canvas.height - (waveData[selectedSampleIndex] * scaleY);
                
                ctx.fillStyle = '#ff3366';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            if (config.selectionStart >= 0 && config.selectionEnd >= 0) {
                const startX = (config.selectionStart / config.waveSize) * canvas.width;
                const endX = (config.selectionEnd / config.waveSize) * canvas.width;
                
                ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.fillRect(startX, 0, endX - startX, canvas.height);
            }
            
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.font = '12px Courier New';
            ctx.fillText(`Cycle ${config.currentCycle}/${config.cycleCount}`, 10, 20);
        }
        
        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 68, 0, 0.5)';
            ctx.lineWidth = 1;
            
            const verticalSteps = config.waveSize > 64 ? 16 : 8;
            for (let i = 0; i <= verticalSteps; i++) {
                const x = (i / verticalSteps) * canvas.width;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let i = 0; i <= 8; i++) {
                const y = (i / 8) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            ctx.strokeStyle = '#007700';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function startDrawing(e) {
            isDrawing = true;
            handleCanvasMove(e);
        }
        
        function handleCanvasMove(e) {
            const rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            
            let sampleIndex = Math.min(
                Math.floor((x / canvas.width) * config.waveSize),
                config.waveSize - 1
            );
            
            let normalizedY = 1 - (y / canvas.height);
            let value = Math.floor(Math.max(0, Math.min(1, normalizedY)) * 65535);
            
            switch(config.axisMode) {
                case 'x': 
                    if (lastValue !== -1 && isDrawing) {
                        value = lastValue;
                    } else {
                        lastValue = value;
                    }
                    break;
                    
                case 'y':
                    if (lastSampleIndex !== -1 && isDrawing) {
                        sampleIndex = lastSampleIndex;
                    } else {
                        lastSampleIndex = sampleIndex;
                    }
                    break;
                    
                case 'both':
                default:
                    lastSampleIndex = sampleIndex;
                    lastValue = value;
                    break;
            }
            
            cursorPos.textContent = `Pos: ${sampleIndex}, Value: ${value}`;
            
            highlightSample(sampleIndex);
            
            if (isDrawing) {
                if (waveData[sampleIndex] !== value) {
                    waveData[sampleIndex] = value;
                    config.originalWaveData[sampleIndex] = value;
                    config.cyclesData[config.currentCycle - 1][sampleIndex] = value;
                    updateHexByte(sampleIndex);
                    drawWaveform();
                    updateStatus();
                }
            }
        }
        
        function stopDrawing() {
            isDrawing = false;
        }
        
        function highlightSample(index) {
            clearHighlights();
            selectedSampleIndex = index;
            
            const percent = (index / config.waveSize) * 100;
            samplePointer.style.left = `${percent}%`;
            samplePointer.style.display = 'block';
            
            if (hexByteElements[index]) {
                hexByteElements[index].classList.add('byte-highlight');
                if (!isDrawing) {
                    hexByteElements[index].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            }
            
            sampleInfo.textContent = `Sample: ${index}, Value: ${waveData[index]}`;
            sampleInfo.style.left = `${percent}%`;
            sampleInfo.style.display = 'block';
        }
        
        function clearHighlights() {
            hexByteElements.forEach(byte => {
                if (byte) byte.classList.remove('byte-highlight');
            });
            sampleInfo.style.display = 'none';
        }
        
        function updateStatus() {
            status.textContent = `Samples: ${config.waveSize}, Range: 0-65535, Cycle: ${config.currentCycle}/${config.cycleCount}`;
        }
        
        function exportWav() {
            try {
                const allCyclesData = new Uint16Array(config.waveSize * config.cycleCount);
                for (let i = 0; i < config.cycleCount; i++) {
                    const cycleData = config.cyclesData[i] || new Uint16Array(config.waveSize).fill(32768);
                    allCyclesData.set(cycleData, i * config.waveSize);
                }
                
                const bitDepth = 16;
                const sampleRate = 44100;
                const numChannels = 1;
                const numSamples = allCyclesData.length;
                
                const blockAlign = numChannels * (bitDepth / 8);
                const byteRate = sampleRate * blockAlign;
                const dataSize = numSamples * blockAlign;
                const fileSize = 36 + dataSize;
                
                const buffer = new ArrayBuffer(44 + dataSize);
                const view = new DataView(buffer);
                
                writeString(view, 0, 'RIFF');
                view.setUint32(4, fileSize, true);
                writeString(view, 8, 'WAVE');
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, bitDepth, true);
                writeString(view, 36, 'data');
                view.setUint32(40, dataSize, true);
                
                const offset = 44;
                for (let i = 0; i < numSamples; i++) {
                    const normalizedValue = allCyclesData[i] / 65535;
                    const sample = Math.floor(normalizedValue * 65535 - 32768);
                    view.setInt16(offset + i * 2, sample, true);
                }
                
                const blob = new Blob([view], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `waveform_${config.cycleCount}cycles.wav`;
                a.click();
                
                status.textContent = `Exported WAV (${config.cycleCount} cycles)`;
            } catch (e) {
                status.textContent = 'WAV export error: ' + e.message;
            }
        }
        
        function importWav() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.wav,audio/wav';
            
            input.onchange = e => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = event => {
                    try {
                        const arrayBuffer = event.target.result;
                        const view = new DataView(arrayBuffer);
                        
                        if (readString(view, 0, 4) !== 'RIFF' || readString(view, 8, 4) !== 'WAVE') {
                            throw new Error('Not a valid WAV file');
                        }
                        
                        let offset = 12;
                        let foundFormat = false;
                        while (offset < view.byteLength) {
                            const chunkId = readString(view, offset, 4);
                            const chunkSize = view.getUint32(offset + 4, true);
                            
                            if (chunkId === 'fmt ') {
                                foundFormat = true;
                                
                                const format = view.getUint16(offset + 8, true);
                                if (format !== 1) {
                                    throw new Error('Only PCM WAV files are supported');
                                }
                                
                                const numChannels = view.getUint16(offset + 10, true);
                                if (numChannels !== 1) {
                                    throw new Error('Only mono WAV files are supported');
                                }
                                
                                config.sampleRate = view.getUint32(offset + 12, true);
                                
                                const bitDepth = view.getUint16(offset + 22, true);
                                if (![8, 16, 32].includes(bitDepth)) {
                                    throw new Error('Only 8, 16, or 32-bit WAV files are supported');
                                }
                                break;
                            }
                            
                            offset += 8 + chunkSize;
                        }
                        
                        if (!foundFormat) {
                            throw new Error('No format chunk found in WAV file');
                        }
                        
                        offset = 12;
                        let foundData = false;
                        while (offset < view.byteLength) {
                            const chunkId = readString(view, offset, 4);
                            const chunkSize = view.getUint32(offset + 4, true);
                            
                            if (chunkId === 'data') {
                                foundData = true;
                                const dataOffset = offset + 8;
                                const bitDepth = 16;
                                
                                const bytesPerSample = bitDepth / 8;
                                const numSamples = chunkSize / bytesPerSample;
                                
                                const detectedCycleCount = Math.max(1, Math.floor(numSamples / config.waveSize));
                                
                                if (detectedCycleCount > 1) {
                                    if (confirm(`WAV file contains ${detectedCycleCount} cycles. Change editor to use this number of cycles?`)) {
                                        config.cycleCount = detectedCycleCount;
                                        config.currentCycle = 1;
                                    }
                                }
                                
                                config.cyclesData = [];
                                for (let cycle = 0; cycle < config.cycleCount; cycle++) {
                                    const newData = new Uint16Array(config.waveSize);
                                    for (let i = 0; i < config.waveSize; i++) {
                                        const sampleIndex = cycle * config.waveSize + i;
                                        if (sampleIndex >= numSamples) break;
                                        
                                        if (dataOffset + sampleIndex * bytesPerSample >= view.byteLength) {
                                            break;
                                        }
                                        
                                        let sampleValue;
                                        if (bitDepth === 8) {
                                            sampleValue = view.getUint8(dataOffset + sampleIndex * bytesPerSample);
                                            newData[i] = Math.floor(sampleValue / 255 * 65535);
                                        } else if (bitDepth === 16) {
                                            sampleValue = view.getInt16(dataOffset + sampleIndex * 2, true);
                                            newData[i] = Math.floor((sampleValue + 32768) / 65535 * 65535);
                                        } else if (bitDepth === 32) {
                                            sampleValue = view.getInt32(dataOffset + sampleIndex * 4, true);
                                            newData[i] = Math.floor((sampleValue + 2147483648) / 4294967295 * 65535);
                                        }
                                    }
                                    config.cyclesData[cycle] = newData;
                                }
                                
                                waveData.set(config.cyclesData[0] || new Uint16Array(config.waveSize).fill(32768));
                                config.originalWaveData = new Uint16Array(waveData);
                                config.smoothness = 0;
                                smoothnessInput.value = 0;
                                selectedSampleIndex = -1;
                                samplePointer.style.display = 'none';
                                
                                updateCycleControls();
                                renderEditor();
                                drawWaveform();
                                updateStatus();
                                status.textContent = `Loaded WAV (${config.cycleCount} cycles)`;
                                break;
                            }
                            
                            offset += 8 + chunkSize;
                        }
                        
                        if (!foundData) {
                            throw new Error('No data chunk found in WAV file');
                        }
                    } catch (err) {
                        status.textContent = 'WAV import error: ' + err.message;
                    }
                };
                reader.readAsArrayBuffer(file);
            };
            
            input.click();
        }
        
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        function readString(view, offset, length) {
            let string = '';
            for (let i = 0; i < length; i++) {
                string += String.fromCharCode(view.getUint8(offset + i));
            }
            return string;
        }
        
        function saveWave() {
            try {
                const allCyclesData = new Uint16Array(config.waveSize * config.cycleCount);
                for (let i = 0; i < config.cycleCount; i++) {
                    const cycleData = config.cyclesData[i] || new Uint16Array(config.waveSize).fill(32768);
                    allCyclesData.set(cycleData, i * config.waveSize);
                }
                
                const blob = new Blob([allCyclesData.buffer], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `waveform_${config.cycleCount}cycles.bin`;
                a.click();
                status.textContent = `Saved (${config.cycleCount} cycles)`;
            } catch (e) {
                status.textContent = 'Save error: ' + e.message;
            }
        }
        
        function loadWave() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.bin,.raw';
            
            input.onchange = e => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = event => {
                    try {
                        const arrayBuffer = event.target.result;
                        const dataView = new DataView(arrayBuffer);
                        
                        const detectedSize = arrayBuffer.byteLength / 2;
                        
                        const detectedCycleCount = Math.max(1, Math.floor(detectedSize / config.waveSize));
                        
                        if (detectedCycleCount > 1) {
                            if (confirm(`File contains ${detectedCycleCount} cycles. Change editor to use this number of cycles?`)) {
                                config.cycleCount = detectedCycleCount;
                                config.currentCycle = 1;
                            }
                        }
                        
                        config.cyclesData = [];
                        for (let cycle = 0; cycle < config.cycleCount; cycle++) {
                            const newData = new Uint16Array(config.waveSize);
                            for (let i = 0; i < config.waveSize; i++) {
                                const sampleIndex = cycle * config.waveSize + i;
                                if (sampleIndex * 2 < arrayBuffer.byteLength) {
                                    newData[i] = dataView.getUint16(sampleIndex * 2, true);
                                } else {
                                    newData[i] = 32768;
                                }
                            }
                            config.cyclesData[cycle] = newData;
                        }
                        
                        waveData.set(config.cyclesData[0]);
                        config.originalWaveData = new Uint16Array(waveData);
                        config.smoothness = 0;
                        smoothnessInput.value = 0;
                        selectedSampleIndex = -1;
                        samplePointer.style.display = 'none';
                        
                        updateCycleControls();
                        renderEditor();
                        drawWaveform();
                        updateStatus();
                        status.textContent = `Loaded (${config.cycleCount} cycles)`;
                    } catch (err) {
                        status.textContent = 'Load error: ' + err.message;
                    }
                };
                reader.readAsArrayBuffer(file);
            };
            
            input.click();
        }
        
        function resizeWaveData() {
            const newData = new Uint16Array(config.waveSize);
            
            const copyLength = Math.min(waveData.length, newData.length);
            for (let i = 0; i < copyLength; i++) {
                newData[i] = waveData[i];
            }
            
            for (let i = copyLength; i < newData.length; i++) {
                newData[i] = 32768;
            }
            
            waveData = newData;
            config.originalWaveData = new Uint16Array(newData);
            
            for (let i = 0; i < config.cycleCount; i++) {
                if (config.cyclesData[i]) {
                    const newCycleData = new Uint16Array(config.waveSize);
                    const copyLength = Math.min(config.cyclesData[i].length, config.waveSize);
                    for (let j = 0; j < copyLength; j++) {
                        newCycleData[j] = config.cyclesData[i][j];
                    }
                    for (let j = copyLength; j < config.waveSize; j++) {
                        newCycleData[j] = 32768;
                    }
                    config.cyclesData[i] = newCycleData;
                }
            }
            
            if (config.cyclesData[config.currentCycle - 1]) {
                waveData.set(config.cyclesData[config.currentCycle - 1]);
            }
            
            config.smoothness = 0;
            smoothnessInput.value = 0;
            selectedSampleIndex = -1;
            samplePointer.style.display = 'none';
            renderEditor();
            drawWaveform();
            updateStatus();
            status.textContent = `Resized to ${config.waveSize} samples`;
        }
        
        // Initialize
        window.onload = init;
    </script>
</body>
</html>